Let file x be of size s and file y be of size t where s >>> t

Client 1 starts iput of x to a replication resource which has 4 children. 2 copies have been transferred
and a zero-length file has been registered in the catalog for the 3rd replica. Transfer is ongoing, expecting a file of s bytes.

At this point, Client 2 starts iput of y to the same logical path as x. First 2 replicas of x are overwritten by the bytes of y.
While the transfer of the 3rd replica of x is ongoing, the file location is written over with y. This causes a SYS_COPY_LEN_ERR on
Client 1's transfer and the iput fails. Meanwhile, Client 2 finishes replicating, which results in all copies of y.

The expectation is that y would overwrite the EXISTING replicas of x and then stop replicating - that is, no new replicas will be created and the
rest of the replicas created (of x) would be marked stale.
It would seem that neither of these are happening.







Sounds like we want to just error out on the SYS_COPY_LEN_ERR for now. How does retry play into this?





Current behavior:

SYS_COPY_LEN_ERR returns before replication has finished...
The overwrite only overwrites existing replicas... 
So if there are only 3 replicas out of 10 of x completed, there will be 3 replicas of y due to the overwrite
    > a rebalance is required at this point to get the rest of the replicas






Client 1 runs iput with large file to path "testfile" -> t1
Client 2 runs iput with small file to path "testfile" -> t2

SCENARIO 1:
t1.start
    iput completes, replication begins
    1 or more replications complete
t2.start
    overwrites all the existing replicas and stops
    the rest of the replication fails for t1 and it exits with sys_copy_len_err on whatever file it was repl'ing
    This is probably because writing to the same place at the same time and then the catalog entry no longer matches


SCENARIO 2:
t1.start
    iput starts, empty file in catalog
    transfer begins
t2.start
    writes to the logical path with the smaller file, updates catalog and exits
    t1 fails because catalog no longer matches what is being transferred


So what we want to do is have t2 replicate in scenario 2 to make all the copies...?
    > Because there are no replicas
    > We would end up with 1 replica, the file from t2
    > The option to "skip replication on overwrite" or "skip create new replica on overwrite" would make this behavior like what we have now..?
And we do NOT want to replicate in scenario 1. But then the resource hierarchy is out of balance. But maybe that's what we want.
    > We could end up with 2 or more replicas of the file from t2
    > Nothing from t1
    > Do we want to fix this to finish replicating the rest of them unless the flag is set?

-------------

WHAT HAPPENS ON A NEW PUT OF A FILE TO A REPLICATION RESOURCE

Apr  2 14:35:10 pid:9087 NOTICE: rsDataObjCreate - new create
Apr  2 14:35:10 pid:9087 NOTICE: repl_file_create that's neat
Apr  2 14:35:10 pid:9087 NOTICE: repl_file_create that's neat
Apr  2 14:35:10 pid:9087 NOTICE: repl_file_write let's-a go
Apr  2 14:35:10 pid:9087 NOTICE: repl_file_close hmmmm
Apr  2 14:35:10 pid:9087 NOTICE: _rsDataObjClose - put or copy got that flag tho?
Apr  2 14:35:10 pid:9087 NOTICE: else _call_file_modified_for_modification - is that repl flag in here

New file creation
zero-length file for catalog registration??
actual creation of actual file
start writing file (moving around the bits)
close file
perform operations on file modified
    for replication, this means we start the replication process


Apr  2 14:35:10 pid:9087 NOTICE: repl_file_modified what a shocker
Apr  2 14:35:10 pid:9087 NOTICE: repl'ing [/tempZone/home/rods/testfile] from [PassResc;HeadResc;Rep2] to [PassResc;HeadResc;Rep8] via [CREATE] operation
Apr  2 14:35:10 pid:9087 NOTICE: create_write_replicator- Are we gonna relp that file
Apr  2 14:35:10 pid:9087 NOTICE: calling resolveSingleReplCopy
Apr  2 14:35:10 pid:9087 NOTICE: CREATING NEW REPLICATION TO THE RESOURCE GROUP
Apr  2 14:35:10 pid:9087 NOTICE: repl_file_close hmmmm
Apr  2 14:35:10 pid:9087 NOTICE: repl_file_create that's neat
Apr  2 14:35:10 pid:9087 NOTICE: repl_file_create that's neat
Apr  2 14:35:10 pid:9087 NOTICE: repl_file_write let's-a go
Apr  2 14:35:10 pid:9087 NOTICE: repl_file_close hmmmm
Apr  2 14:35:10 pid:9087 NOTICE: _rsDataObjClose - !open_existing is that repl flag in here

Modified operation for repl resource
down in the create_write_replicator
create new replication
close file -- was it open because we needed to have it open for replication?
create zero-length file for catalog registration??
create actual file
start writing (moving around the bits)
close file

Cycle repeats for each child in the child list


WHAT HAPPENS ON AN OVERWRITE OF A FILE TO A REPLICATION RESOURCE

It's the exact same process except for it's a WRITE operation instead of a CREATE and close modifies the metadata of the data object each time


-----------------







We need to be focusing on the random resource. This is where the potential for multiple replicas comes in

