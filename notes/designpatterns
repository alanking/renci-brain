
Design Patterns

Chapter 1: Intro to Design Patterns

There is one constant in software development: change.
The first, foundational design principle in software...
OO DESIGN PRINCIPLES:
    1. Identify the aspects of your application that vary and separate them from what stays the same.
        Take what varies and encapsulate it so it doesn't affect the rest of your code when you need to alter or extend the parts that vary.
        All patterns provide a way to let some part of a system vary independently of all other parts.
    2. Program to an interface, not an implementation.
        This would mean having object classes use behaviors represented by interfaces rather than locking the behavior into the class itself
        e.g. FlyBehavior is the interface that the Duck class would program to, and the FlyBehavior is implemented in subclasses like FlyWithWings
        Programming to an interface doesn't always mean a literal interface. This could also be an abstract base class.
        The point is the abstraction of the implementation
    3. Favor composition over inheritance
        The HAS-A relationship represents the composition of objects
        The IS-A relationship represents the inheritance of classes from a base class
        The IMPLEMENTS relationship represents the implementation of an interface or abstract base class
        Composition allows for more flexibility like changing out implementations at runtime
The above 3 points are OO principles, not necessarily design patterns - but they do form the basis for all design patterns.

THE STRATEGY PATTERN
    Defines a family of algorithms, encapsulates each one, and makes them interchangeable.
    Strategy lets the algorithm vary independently from clients that use it.
    Example: We are using the Strategy Pattern to implement the various behaviors of our ducks."
    This tells you that the duck behavior has been encapsulated into its own set of classes that can be easily expanded and changed (even at runtime).

Design patterns don't go directly into your code, they first go into your brain.
Once you've loaded your brain with a good working knowledge of patterns, you can then start to apply them to your new designs and rework your old code when you find it's degrading into an inflexible mess of jungle spaghetti code.

---

Chapter 2: The Observer Pattern

THE OBSERVER PATTERN
    Defines a one-to-many dependency between objects so that when one object changes state, all of its dependents are notified and updated automatically.
    A newspaper subscription service with its publisher (Subject) and subscribers (Observers) is a good illustration of the pattern.
    The Subject is the object that contains the state and controls it. The Observers use the state.
    Pattern for communicating state to a set of objects in a loosely coupled manner.

The Observer Pattern provides an object design where Subjects and Observers are loosely coupled - meaning, they can interact, but have very little knowledge of each other.

OO DESIGN PRINCIPLE:
    4. Strive for loosely coupled designs between objects that interact.

Loose coupling is demonstrated in the Observer Pattern in the following ways:
    The only thing the Subject knows about an Observer is that it implements a certain interface. Doesn't need to know the concrete Observer, what it does, or anything else.
    We can add/remove new Observers at any time. The only thing the Subject needs is a list of objects that implement the Observer interface.
    We never need to modify the Subject to add new Observers. To add new Observers, just create a concrete Observer that implements the Observer interface and register with the Subject.
    Since Subjects and Observers are not tightly coupled, we can reuse the classes for other purposes outside of the Observer Pattern relationship.
    Internal changes to the Subject or Observer will not affect the other, as they are only tied by the Observer and Subject interfaces.

There are a few different ways for Subjects to notify Observers about state changes. The two main ways are PUSH and PULL.
In the PUSH model, the Subject sends data out to the Observers whenever update() is called. 
In the PULL model, the Subject notifies Observers of changes, but does not send any data. Instead, it exposes data through getters which the Observers can call to get the data they need in their update() implementations.

---

Chapter 3: The Decorator Pattern

OO DESIGN PRINCIPLE:
    5. Classes should be open for extension, but closed for modification.
        This means that classes should "inherit" behavior at runtime through composition and delegation.
        When you inherit behavior through subclassing, the behavior is set statically at runtime and all subclasses inherit the same behavior. 
        By dynamically composing objects, you can add new functionality by writing new code rather than altering existing code.
        
THE DECORATOR PATTERN
    Attaches additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.

Decorators have the same supertype as the objects they decorate.
You can use one or more Decorators to wrap an object.
Given that the Decorator has the same supertype as the object it decorates, we can pass around a decorated object in place of the original/wrapped object.
The decorator adds its own behavior either before and/or after delegating to the object it decorates to do the rest of the job.
Objects can be decorated dynamically at runtime with as many Decorators as needed.

The Decorator Pattern on its own can easily grow into an unmaintainable mess with the number of classes that need to be created to decorate objects.

---

Chapter 4: The Factory Pattern

Simple Factory:
    Not a design pattern, and often mistaken as the Factory Pattern
    Looks like this:
        Client uses a SimpleFactory to generate instances of some object
        SimpleFactory creates objects - the only place in the application where we refer to concrete objects
        The Product of the SimpleFactory can itself be an abstract class with implementations that can be overridden
        The ConcreteProducts (subclasses of Product) must implement the Product interface, which is used in SimpleFactory, which gives the Product to the Client

A Factory Method handles object creation and encapsulates it in a subclass. This decouples the client code in the superclass from the object creation code in the subclass.
All Factory Patterns encapsulate object creation by letting subclasses decide what objects to create.

THE FACTORY METHOD PATTERN
    Defines an interface for creating an object, but lets subclasses decide which class to instantiate.
    Factory Method lets a class defer instantiation to subclasses.
    Two abstract classes: Product and Creator
        Creator contains the implementations for all of the methods to manipulate Products, except for the Factory Method. This is implemented by Creator's subclasses
        ConcreteCreator, a subclass to Creator, implements the Factory Method, which actually produces Products
            It is the only class that has the knowledge of how to create a particular set of ConcreteProducts
        A Product is an abstract class which defines an object for the Creator to create and manipulate
        ConcreteProducts, subclasses to Product, must implement the same interface so users of the Products can refer to the interface, not the ConcreteProduct

    "Decision" doesn't mean the pattern allows subclasses themselves decide which classes to instantiate, but rather that the Creator class is written without knowledge of the actual Products that will be created. The decision comes in which subclass is chosen for use.

In the example, the PizzaStore is the Creator.
    The NYPizzaStore and ChicagoPizzaStore are the ConcreteCreators
    Pizza is the Product.
    NYStyleCheesePizza, NYStylePepperoniPizza, etc. are ConcreteProducts that only NYPizzaStore knows about.
    ChicagoStyleCheesePizza, ChicagoStylePepperoniPizza, etc. are ConcreteProducts that only ChicagoPizzaStore knows about.
    The example uses what is known as a Parameterized Factory Method, which allows it to create multiple ConcreteProducts based on that parameter.
        It is equally valid to have a non-Parameterized Factory Method and create a single ConcreteProduct.

The Factory Method Pattern is useful even when there is only one ConcreteCreator needed because the creation of the Product is decoupled from its use.
So any changes that come along do not impact the Creator because it is not tightly coupled to any particular ConcreteProduct.

SIMPLE FACTORY vs FACTORY METHOD PATTERN:
    In Simple Factory, the Factory is another concrete object that is composed with the Creator
    In Factory Method Pattern, the Factory Method is an abstract method of the Creator which is left up to each ConcreteCreator to implement

This is important because when the Creator instantiates ConcreteProducts directly, any change in implementation or new ConcreteProduct added requires change in the Creator.

OO DESIGN PRINCIPLE:
    6. Depend upon abstractions. Do not depend upon concrete classes.
        Called the DEPENDENCY INVERSION PRINCIPLE
        In essence, this means that low-level components and high-level components (composed of low-level components) should be dependent on abstractions.
        Low-level components should be dependent on abstractions too. And high-level components should not depend directly on low-level components.
        In some cases, the low-level and high-level components can depend on the same abstraction! "Inverts" the way we think about OO design

How to follow the Dependency Inversion Principle:
    No variable should hold a reference to a concrete class. (Use factory methods instead of new)
    No class should derive from a concrete class. Always derive from an abstraction, like an interface or abstract class.
    No method should override an implemented method of any of its base classes. If you are overriding an implemented method, the base class was not an abstraction.

These are GUIDELINES and are okay to be violated, with a good reason.

THE ABSTRACT FACTORY PATTERN
    Provides an interface for creating families of related or dependent objects without specifying their concrete classes.
    Abstract Factory allows a client to use an abstract interface to create a set of related Products without knowing about the Concrete Products being produced.
    Client is written against the Abstract Factory and composed at runtime with a Concrete Factory.
    Abstract Factory defines an interface that all Concrete Factories must implement, which consists of a set of methods for producing Products.
    Concrete Factories implement the different Product Families.
    To create a Product, the Client uses one of these Concrete Factories so it never has to instantiate a Product. Once again, determined at runtime.
    The Product Families are a set of Abstract Products that the Client produces via the Abstract Factory.
    The Concrete Factories use their implemented interfaces to create Concrete Products, which implement an Abstract Product.
   
Often, methods of an Abstract Factory are implemented as Factory Methods. Abstract Factory's job is to define an interface for creating a set of Products.
Each method in that interface is responsible for creating a Concrete Product and we implement the Concrete Factories to supply those implementations.
Factory Methods are a natural way to implement your Product methods in your Abstract Factories.

ABSTRACT FACTORY PATTERN vs FACTORY METHOD PATTERN:
    Factory Method uses classes (inheritance) to create Products. Abstract Factory uses objects (composition) to create Products.
    To create objects using Factory Method Pattern, you must EXTEND a class and OVERRIDE a Factory Method.
    Abstract Factory provides an abstract type for creating a "family" of Products. Subclasses define how those Products are produced.
    To create objects using Abstract Factory Pattern, you must instantiate a Concrete Factory which implements the Abstract Factory, and pass this into the Product code.
        This means that the interface of the Abstract Factory must change whenever a new Product is added to its supported "family".
    Factory Method Pattern is for decoupling client code from Concrete Products. Useful when Concrete Products are not all known up front (easy to add more).
    Abstract Factory Pattern is for creating families of Products that belong together and are known ahead of time.
        Often times, the methods for creating Products implemented by Concrete Factories conform to the Factory Method Pattern themselves.

All Factories encapsulate object creation, and Factory Patterns promote loose coupling by reducing dependency of the application on concrete classes.

---

Chapter 5: The Singleton Pattern

THE SINGLETON PATTERN
    Ensures a class has only one instance, and provides a global point of access to it.

In the Classic Singleton implementation, the initialization and instantiation of the Singleton object happens in the same getInstance() method.
This allows for lazy initialization by only initializing the Singleton when an instance is needed.
In a multi-threaded environment where performance is important, the instance may need to be initialized "eagerly" in order to prevent multiple instances being created.
You can also use double-checked locking by only synchronizing threading the first time through the getInstance() method.


---


